#!/usr/bin/python
# encoding=UTF-8

# Copyright © 2009, 2010, 2012, 2014 Jakub Wilk <jwilk@jwilk.net>
#
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# “Software”), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:
#
# The above copyright notice and this permission notice shall be included
# in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
# CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
# TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
# SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

from __future__ import with_statement

import argparse
import datetime
import errno
import fcntl
import locale
import os
import re
import cPickle as pickle

import debianbts

debianbts.URL = re.sub('^http://', 'https://', debianbts.URL)
debianbts.server = debianbts.SOAPpy.SOAPProxy(debianbts.URL, debianbts.NS)
# XXX Caveat: while debianbts can speak to the BTS over HTTPS, to the best of
# our knowledge, it does not verify the server's TLS certificate. It's a shame,
# but it's still better than talking to the BTS over HTTP.

try:
    import elinks
    encoding_error_handler = 'elinks'
except ImportError:
    encoding_error_handler = 'replace'

encoding = locale.getpreferredencoding()

class xdg(object):
    '''
    tiny replacement for PyXDG's xdg.BaseDirectory
    '''
    xdg_data_home = os.environ.get('XDG_DATA_HOME') or ''
    if not os.path.isabs(xdg_data_home):
        xdg_data_home = os.path.join(os.path.expanduser('~'), '.local', 'share')

    @classmethod
    def save_data_path(xdg, resource):
        path = os.path.join(xdg.xdg_data_home, resource)
        try:
            os.makedirs(path, 0700)
        except OSError:
            if not os.path.isdir(path):
                raise
        return path

class file_lock(object):
    def __init__(self, filename):
        self._filename = filename + '.lock'
        self._stale_filename = filename + '.stale-lock'
        # *.stale-lock should appear in the filesystem only for a short period of time

    def __enter__(self):
        stale_fd = os.open(self._stale_filename, os.O_CREAT | os.O_RDWR | os.O_EXCL, 0600)
        try:
            self._fd = os.open(self._filename, os.O_CREAT | os.O_RDWR | os.O_TRUNC, 0600)
            fcntl.flock(self._fd, fcntl.LOCK_EX | fcntl.LOCK_NB)
        finally:
            os.unlink(self._stale_filename)
            os.close(stale_fd)

    def __exit__(self, ex_type, ex_value, ex_traceback):
        stale_fd = os.open(self._stale_filename, os.O_CREAT | os.O_RDWR | os.O_EXCL, 0600)
        try:
            try:
                os.unlink(self._filename)
            except IOError:
                pass
            os.close(self._fd)
        finally:
            os.unlink(self._stale_filename)
            os.close(stale_fd)

def get_email():
    return os.getenv('REPORTBUGEMAIL') or os.getenv('EMAIL') or os.getenv('DEBEMAIL')

def fetch_bugs(requests, options):
    email = get_email()
    basename, ext = os.path.splitext(__file__)
    os.chdir(xdg.save_data_path('freshbugs'))
    stamp_filename = 'freshbugs.stamp'
    with file_lock(stamp_filename):
        try:
            with open(stamp_filename, 'rb') as stamp_file:
                stamp = pickle.load(stamp_file)
        except IOError, ex:
            if ex.errno == errno.ENOENT:
                stamp = {}
            else:
                raise
        bugs = set()
        for request in requests:
            try:
                bugs.add(int(request, 10))
            except ValueError:
                for key in 'maint', 'submitter', 'owner', 'correspondent':
                    bugs_chunk = debianbts.get_bugs(key, request)
                    bugs.update(bugs_chunk)
        bugs = debianbts.get_status(*bugs)
        bugs.sort(key = lambda bug: bug.log_modified, reverse=True)
        new_stamp = {}
        ancient_timestamp = datetime.datetime(1900, 1, 1)
        for bug in bugs:
            no = int(bug.bug_num)
            new_stamp[no] = bug.log_modified
            if options.all or bug.log_modified > stamp.get(no, ancient_timestamp):
                print 'Package: %s' % bug.package
                if bug.originator is not None:
                    submitter_email = bug.originator
                    match = re.search('<(.*)>', submitter_email)
                    if match is not None:
                        submitter_email = match.group(1)
                    if submitter_email != email:
                        print 'Submitter: %s' % bug.originator.encode(encoding, encoding_error_handler)
                print 'Subject: %s' % bug.subject.encode(encoding, encoding_error_handler)
                print 'Date: %s' % bug.log_modified
                print 'Location: https://bugs.debian.org/%d' % no
                print
        if options.dry_run:
            return
        if not options.clean:
            merged_stamp = dict(stamp)
            merged_stamp.update(new_stamp)
            new_stamp = merged_stamp
        with open(stamp_filename + '~', 'wb') as stamp_file:
            pickle.dump(new_stamp, stamp_file, protocol=-1)
        os.rename(stamp_filename + '~', stamp_filename)

class ArgumentParser(argparse.ArgumentParser):
    def __init__(self):
        argparse.ArgumentParser.__init__(self)
        self.add_argument('--dry-run', action='store_true', help='make cache read-only')
        self.add_argument('--clean', action='store_true', help='allow to remove old items from cache')
        self.add_argument('--all', action='store_true', help='print all selected bugs\' details')
        self.add_argument('request', metavar='<request>', nargs='+', help='either a bug number or an e-mail address')

def main():
    options = ArgumentParser().parse_args()
    fetch_bugs(options.request, options)

if __name__ == '__main__':
    main()

# vim:ts=4 sw=4 et
